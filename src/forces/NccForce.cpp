/** NccForce.cyclicEn -- 
 **
 ** Copyright (C) 2004
 ** Centre for Molecular Simulation (CMS)
 ** School of Information Technology
 ** Swinburne University of Technology
 ** PO Box 21 Hawthorn, Vic 3122, Australia
 **
 ** Author: Jianhui Li
 ** Email: jli@it.swin.edu.au
 **/
//JC this is a child class of Force, at the similar level of the LFForce and Ewarld class
//JC nowthat the unit system is unclear till now, the reasonable method to verify is to assume
//JC all the parameters in the potential in atomic unit, 

//JC Energy unit: Hartree (Eh) is the physical constant = 4.3597438134e-18 J =27.2144eV
//JC Eh=H*H/(Me*A0), where H is the dirac constant; Me is the electron rest mass;A0 is the Bohr radius

//JC Length: Bohr radius, having a value of 5.29189379e-11m, about 53 picometers(half of Angstrom) is used
//JC         in a perturbative expansions of wave function
//JC Electrical Charge; unit is elementary charge, the fundamental physical constant, and the 
//JC having a value of 1.60217646263e-19 C,
//JC 

//JC Mass: taking the rest mass of the electron, 9.10e-31 Kg 

//JC In this version, the induction is added to represent the induction effecs in the polar molecules system
//Jc:the induced dipoles are calcualted by the iteration process  


#include "NccForce.h" 
#include "mpi.h"
#include <time.h>

NccForce::NccForce(Ensemble* ensemble) : Force(ensemble) //Constructor
{
    #ifdef DEBUG
        DEBUGMSG("Creating NccForce  ");  
    #endif
//Jc: forceIdentifier = "NccForce";
    mols = myEnsemble->molecules;
    numAtoms = myEnsemble->nAtoms;  
    numMols = myEnsemble->nMols;
    params = myEnsemble->myParams; 
    cutOff = myEnsemble->myConfig->get_cutoff();
    cutOff2 = cutOff*cutOff;
    switchDist = cutOff2; // JC:          
    switchOn = myEnsemble->myConfig->is_switch_on();
    CNum = 0;
    computeEwald = myEnsemble->myConfig->compute_ewald_force();  //Jc: need to set "false" for comlumbic calcualtion
    P2Sum = 0.0;       // Jc: initialize the Time average value of dipole moment
    PSum  = 0.0;       // Jc: initialize the Time average value of dipole moment
    DipoleSum.x = 0.0;
    DipoleSum.y = 0.0;
    DipoleSum.z = 0.0; 
//    rank = MPI::COMM_WORLD.Get_rank();   Updated to MPI-3 Elton
//    size = MPI::COMM_WORLD.Get_size();
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (switchOn)
        switchDist = myEnsemble->myConfig->get_switch_distance()*myEnsemble->myConfig->get_switch_distance();
    if (switchOn && (cutOff2 > switchDist))
    {
        c1 = 1.0/(cutOff2 - switchDist);
        c1 = c1*c1*c1;
        c2 = cutOff2 - 3.0*switchDist;
        c3 = 4*c1;
    }
    else
    {
        c1 = 0.0;
        c2 = 0.0;
        c3 = 0.0;
    }
    cout<<" data generated by NccForce.cyclicE "<<endl;
    halfLx = 0.5*myEnsemble->boxLx;
    halfLy = 0.5*myEnsemble->boxLy;
    halfLz = 0.5*myEnsemble->boxLz;
    
    ofEnergy = new ofstream("induction.out",ios::out);

    if(rank == 0)
    {
      //*ofEnergy<<left;
      *ofEnergy<<"## TimeStep        "<<"Dipole        "<<"Dielectric Constant  "<<endl;
    } 
}

// Jc: DummyPosition calculates the coordinates of the dummy negative charges 
// Jc: for each of the Molecule based on the 3 nuceli positions  

void NccForce::DummyPosition()

{
   Vector3 Roh1, Roh2, Rhh, Rpo, Dummyi;
   Atom *atom1, *atom2, *atom3;
   Double  RRpo;

   for (int i = 0;i<numMols;i++)
   {
    int j = 3 * i;
    atom1 = &atoms[j];
    atom2 = &atoms[j + 1];
    atom3 = &atoms[j + 2];

    Rpo.x = 0.5*(atom3->position.x + atom1->position.x); 
    Rpo.y = 0.5*(atom3->position.y + atom1->position.y);
    Rpo.z = 0.5*(atom3->position.z + atom1->position.z);
    Rpo   = Rpo - atom2->position;
    RRpo  = Rpo.length(); 
    Dummyi = atom2->position + (R_OP/(RRpo*F_Length))*Rpo; // Jc: RRpo was given in Bohr Unit!
    Dummy[j]     = Dummyi.x;
    Dummy[j + 1] = Dummyi.y;
    Dummy[j + 2] = Dummyi.z;
   }
}

// Jc: force calcualtion, but the integration process is done 
// Jc: in another class named Integrator
void NccForce::seperator()
{
  ;
}

void NccForce::compute()  
{
   Atom *atomi;
   Atom *atomih1,*atomih2,*atomio, atomid;
   Atom *atomjh1,*atomjh2,*atomjo, atomjd;
   Atom *atomt;
   Atom *atomA,  *atomB,  *atomC;

   Vector3 rij, fij, distance, rtemp, atomPosition, Etemp, Dipole, inDipole;   
   Vector3 rA, rB, rC, fijA, fijB, fijC,Ei0Temp,Ej0Temp,PiTemp,PjTemp;            
    
   double dA1,dA2,dA3,dA4,dA5,dA6;
   double dB1,dB2,dB3,dB4,dB5,dB6;
   double dC1,dC2,dC3,dC4,dC5,dC6;
   double dVdRa,dVdRb,dVdRc;
   double u3 = 0.0;
   double indSwitch = 0.0;
   double Alpha = 0.0;

   double scaledQ = Q*SQRTCOULOMBCONSTANT; // Jc: scaled the partial charge to 

   double r, rij2, rij3, rij5, r_cutoff, r4_cutoff4;

   double B_cutoff  = cutOff * F_Length*2;     // Jc: change to the a.u unit 
   double B_cutoff2 = B_cutoff * B_cutoff;
   double T_cutoff  = 0.25*myEnsemble->boxLx;
   double inCutoff2 = 0.81 ; // Jc: cutoff for Induction Energy
   double Einduc, EInduc, dEinddV, voll, vol2, pTp;
   double rijRij;

   voll = myEnsemble->boxLx*myEnsemble->boxLy*myEnsemble->boxLz;
   vol2 = voll*voll;
// Jc: timing variables
   double p_time, pp_time[100];
   int    counterc[100],nCounter, tStep=70;
   int    i3, j3;
   for(int numProcs=0; numProcs<101; numProcs++)
   {
     pp_time[numProcs] = 0.0; counterc[numProcs] = 0;     
   }     
   clock_t start1,end1,start2,end2,start3;

   start1 = clock();

   Vector3 rim, rjm, rijm, EijrR, TRij;
   double  molVirial[9];
   double  temf= 0.0, teme = 0.0, temf1 = 0.0;
   double  Ctemp, Wtemp;
   double  scalarD = 0.0;

   Ctemp = 0.0, Wtemp = 0.0;    
   energy = 0.0;
   WPotential = 0.0,CPotential = 0.0;
// Jc: generate the file name each interation!!

   DummyPosition();               // Jc: update dummy position 

   for (int i = XX; i <= ZZ; i++) // Jc: XX and ZZ Wirial components cf. NEMD_defs.h
   {
     virial[i] = 0.0;             // Jc: reset the virial components
     molVirial[i] = 0.0;       
   }

// JC calculation of assumed negative charges
   double CHH = 0.0; // the coulombic energy between H-H pairs
   double CHD = 0.0; // the coulombic energy between H-Negative pairs
   double CDD = 0.0; // the coulombic energy between Dummy-Dummy pairs
   double WHH = 0.0; // the Van der Waals interaction between H-H pairs
   double WOO = 0.0; // the Van dre Waals interaction between O-O pairs
   double WHD = 0.0; // the Van der Waals interaction between H-D pairs
   double WOD = 0.0; // the Van der Waals interaction between O-D pairs
   double WHO = 0.0; // the Van der Waals interaction between O-D pairs

// temp Potential of Certain Molecule
   double MCHH = 0.0;// the coulombic energy between H-H pairs
   double MCHD = 0.0;// the coulombic energy between H-Negative pairs
   double MCDD = 0.0;// the coulombic energy between Dummy-Dummy pairs
   double MWHH = 0.0;// the Van der Waals interaction between H-H pairs
   double MWOO = 0.0;// the Van dre Waals interaction between O-O pairs
   double MWHD = 0.0;// the Van der Waals interaction between H-D pairs
   double MWOD = 0.0;// the Van der Waals interaction between O-D pairs
   double MWHO = 0.0;// the Van der Waals interaction between O-D pairs
   int flag = 1;     //flag

// Jc: calculate the non-additive effects(induction) in the water system
// Jc: this calcualtion is done based on the method introduced by Liem X.Dang
// Jc: in his paper(1997, index as 20051005005PE ) "Molecular Dynamics study of water clusters, liquid, and liquid-vapor
// Jc: interface of water with many-body potentials", the induction was introduced as one of the non-additive interactions 
// Jc: with rigid model based on the MCY, the polariazation was placed on the Dummy point and polarizzbility was
// Jc: fitted into the dipole moment in the gas phase,
  
// Jc: calculate the alpha*Ei0 = B, and A 
// Jc: all the processors perform the same calcualtion 

   Einduc = 0.0; EInduc = 0.0;
   dEinddV = 0.0;

   if(indSwitch == 1.0) {
   fij.x = 0.0; fij.y = 0.0; fij.z = 0.0;    
   for(int i = 0; i<numAtoms;i++)
   {
      Ei0[i] = 0.0;
      Pi[i]  = 0.0;
      for(int j = 0; j<numAtoms;j++)
      {
        A[i][j] = 0.0;
      } 
   }
   for(int i = 0; i<numMols; i++)
   {
     Ei0Temp = 0.0;
     for(int j = i+1; j<numMols; j++)
     {
       Ej0Temp = 0.0;
       i3 = 3 * i;
       rij.x  = Dummy[i3];
       rij.y  = Dummy[i3 + 1];
       rij.z  = Dummy[i3 + 2];
       atomih1 = &atoms[i3];
       atomih2 = &atoms[i3 + 2];
       atomio  = &atoms[i3 + 1];
       atomid.position = rij;  

       j3 = 3 * j;
       rij.x  = Dummy[j3];
       rij.y  = Dummy[j3 + 1];
       rij.z  = Dummy[j3 + 2];
       atomjh1 = &atoms[j3];
       atomjh2 = &atoms[j3 + 2];
       atomjo  = &atoms[j3 + 1];
       atomjd.position = rij; 

       rij      = atomjo->position - atomio->position;
       myEnsemble->apply_pbc(rij);
       rij2     = rij.length()*rij.length();

       if(rij2<= inCutoff2)  // Jc: from the 
       {
         // Jc: contribution from the Pi - Hj1       
         rij      = atomid.position - atomjh1->position;//Jc: as tested, there should be cutoff in the calcualtion
         myEnsemble->apply_pbc(rij);
         rij3     = rij.length()*rij.length()*rij.length();
         Etemp    = Q*rij/rij3;

         KSwitch[i][j*9]   = Etemp.x;
         KSwitch[i][j*9+1] = Etemp.y;
         KSwitch[i][j*9+2] = Etemp.z;
         Ei0Temp += Etemp;                            //Jc: 20060126001 eq. (3) p565

         // Jc: contribution from the Pi - Hj2       
         rij      = atomid.position -  atomjh2->position;
         myEnsemble->apply_pbc(rij);
         rij3     = rij.length()*rij.length()*rij.length();
         Etemp    = Q*rij/rij3;
         KSwitch[i][j*9+6] = Etemp.x;
         KSwitch[i][j*9+7] = Etemp.y;
         KSwitch[i][j*9+8] = Etemp.z;
         Ei0Temp += Etemp;                            //Jc: 20060126001 eq. (3) p565

         // Jc: contribution from the Pi - Oj       
         rij      = atomid.position - atomjd.position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij.length()*rij.length();
         rij5     = rij3 * rij2;
         Etemp    = -2*Q*rij/rij3;
         KSwitch[i][j*9+3] = Etemp.x;
         KSwitch[i][j*9+4] = Etemp.y;
         KSwitch[i][j*9+5] = Etemp.z;
         Ei0Temp += Etemp;                            //Jc: 20060126001 eq. (3) p565

// Jc: calculae Tij      
         Tij[0][0] = (polar*(3*(rij.x)*(rij.x)-rij2)/rij5);  //Jc: 20060126001 eq. (3) p565
         Tij[0][1] = (polar* 3*(rij.x)*(rij.y)/rij5);        //Jc: details referred to 20060219005PE eq. (4), p9339 
         Tij[0][2] = (polar* 3*(rij.x)*(rij.z)/rij5);
         Tij[1][0] = Tij[0][1]; 
         Tij[1][1] = (polar*(3*(rij.y)*(rij.y)-rij2)/rij5); 
         Tij[1][2] = (polar* 3*(rij.y)*(rij.z)/rij5);
         Tij[2][0] = Tij[0][2]; 
         Tij[2][1] = Tij[1][2]; 
         Tij[2][2] = (polar*(3*(rij.z)*(rij.z)-rij2)/rij5);
// Jc: calculate Tji according to (Tji = Tij)               //Jc: to 20060219005PE eq. (4)

// Jc: initilize A matrix
         A[i3][j3]   = -Tij[0][0];A[i3][j3+1]   = -Tij[0][1];A[i3][j3+2]   = -Tij[0][2];                    
         A[i3+1][j3] = -Tij[1][0];A[i3+1][j3+1] = -Tij[1][1];A[i3+1][j3+2] = -Tij[1][2];  
         A[i3+2][j3] = -Tij[2][0];A[i3+2][j3+1] = -Tij[2][1];A[i3+2][j3+2] = -Tij[2][2];  

         A[j3][i3]   = -Tij[0][0];A[j3][i3+1]   = -Tij[0][1];A[j3][i3+2]   = -Tij[0][2];                    
         A[j3+1][i3] = -Tij[1][0];A[j3+1][i3+1] = -Tij[1][1];A[j3+1][i3+2] = -Tij[1][2];  
         A[j3+2][i3] = -Tij[2][0];A[j3+2][i3+1] = -Tij[2][1];A[j3+2][i3+2] = -Tij[2][2];  

         KSwitch[j][i*9+3] = -(Etemp.x);
         KSwitch[j][i*9+4] = -(Etemp.y);
         KSwitch[j][i*9+5] = -(Etemp.z);

         Ej0Temp += (2*Q*rij/rij3);                   //Jc: 20060126001 eq. (3) p565

         // Jc: contribution from the Pj - Hi1  
         rij      =  atomjd.position - atomih1->position;
         myEnsemble->apply_pbc(rij);
         rij3     = rij.length()*rij.length()*rij.length();
         Etemp    = Q*rij/rij3;
         KSwitch[j][i*9]   = Etemp.x;
         KSwitch[j][i*9+1] = Etemp.y;
         KSwitch[j][i*9+2] = Etemp.z;
         Ej0Temp += Etemp;                                  //Jc: 20060126001 eq. (3) p565

         // Jc: contribution from the Pj - Hi2  
         rij      =  atomjd.position - atomih2->position;
         myEnsemble->apply_pbc(rij);
         rij3     = rij.length()*rij.length()*rij.length();
         Etemp    = Q*rij/rij3;
         KSwitch[j][i*9+6] = Etemp.x;
         KSwitch[j][i*9+7] = Etemp.y;
         KSwitch[j][i*9+8] = Etemp.z;
         Ej0Temp += Etemp;                                  //Jc: 20060126001 eq. (3) p565
     
       }
       Ei0[j3]   += polar * Ej0Temp.x;
       Ei0[j3+1] += polar * Ej0Temp.y;
       Ei0[j3+2] += polar * Ej0Temp.z;
     }
     Ei0[i3]   += polar * Ei0Temp.x;
     Ei0[i3+1] += polar * Ei0Temp.y;
     Ei0[i3+2] += polar * Ei0Temp.z;
   } 


// Jc: set up diagonal elements
   for(int i = 0; i<numMols; i++)
   { 
     i3 = 3*i;
 
     Ei0[i3]     =  Ei0[i3];                               // Jc: setup the Right-side "B"
     Ei0[i3+1]   =  Ei0[i3+1];
     Ei0[i3+2]   =  Ei0[i3+2];

     A[i3][i3]   = 1; A[i3][i3+1]   = 0; A[i3][i3+2]   = 0;  
     A[i3+1][i3] = 0; A[i3+1][i3+1] = 1; A[i3+1][i3+2] = 0;  
     A[i3+2][i3] = 0; A[i3+2][i3+1] = 0; A[i3+2][i3+2] = 1;  
   } 

// Jc: Gauss Elimination, returned value of B is P
   for(int i = 0; i<(3*numMols);i++)
   {
     Pi[i] = Ei0[i];
   }

//   GaussElimination();
   ConjugateGradient(); 

/*double Tijpj = 0.0;
for (int i = 1; i < (numMols);i++){
       PjTemp.x = Pi[3*i];
       PjTemp.y = Pi[3*i+1];
       PjTemp.z = Pi[3*i+2];
 
       rij.x  = Dummy[3*i];
       rij.y  = Dummy[3*i + 1];
       rij.z  = Dummy[3*i + 2];
       
       rij.x = rij.x - Dummy[0];
       rij.y = rij.y - Dummy[1];
       rij.z = rij.z - Dummy[2];

       myEnsemble->apply_pbc(rij);
       rij2     = rij.length()*rij.length();
       rij5     = rij2*rij2*rij.length();
 
       Tijpj += (PjTemp.x*(3*rij.x*rij.x-rij2) + PjTemp.y*(3*rij.x*rij.y) + PjTemp.z*(3*rij.x*rij.z))/(rij5);
}
double bAx = - Pi[0] + Ei0[0] + polar*Tijpj;
if (rank == 0){
cout << "Min_ind = " << bAx << endl;}*/


   for(int i = 0; i<(3*numMols);i++)
   {
     Pi[i]  = SQRTCOULOMBCONSTANT*Pi[i];
     Ei0[i] = SQRTCOULOMBCONSTANT*Ei0[i];
   }
  
   for(int i = 0; i<numMols; i++)
   {
     for(int j = i+1; j<numMols; j++)
     {
	 KSwitch[i][j*9]   = SQRTCOULOMBCONSTANT*KSwitch[i][j*9];
         KSwitch[i][j*9+1] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+1];
         KSwitch[i][j*9+2] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+2];
	 KSwitch[i][j*9+3] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+3];
         KSwitch[i][j*9+4] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+4];
         KSwitch[i][j*9+5] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+5];
	 KSwitch[i][j*9+6] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+6];
         KSwitch[i][j*9+7] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+7];
         KSwitch[i][j*9+8] = SQRTCOULOMBCONSTANT*KSwitch[i][j*9+8];

	 KSwitch[j][i*9]   = SQRTCOULOMBCONSTANT*KSwitch[j][i*9];
         KSwitch[j][i*9+1] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+1];
         KSwitch[j][i*9+2] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+2];
	 KSwitch[j][i*9+3] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+3];
         KSwitch[j][i*9+4] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+4];
         KSwitch[j][i*9+5] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+5];
	 KSwitch[j][i*9+6] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+6];
         KSwitch[j][i*9+7] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+7];
         KSwitch[j][i*9+8] = SQRTCOULOMBCONSTANT*KSwitch[j][i*9+8];
     }
   }


/*for (int i = 0; i < (numMols);i++){
       PjTemp.x = Pi[3*i];
       PjTemp.y = Pi[3*i+1];
       PjTemp.z = Pi[3*i+2];

       Einduc += - 0.5*( PjTemp.x*Ei0[i*3] + PjTemp.y*Ei0[i*3+1] + PjTemp.z*Ei0[i*3+2] ); 
}*/

// Jc: calculate the inductive forces and Induction Energy
// Jc: there are force calculated inthis part, parallelization is necessary
// Jc: at first, cyclic method is simply implemented

   int numDecompose = (int) numMols/size;
   if ((numMols % size) == 0) numDecompose--;
   for(int k = 0; k <= numDecompose;k++)     // Jc: molID = i
   { 
     int molIndex = k*size + rank;
     if(molIndex <= (numMols -2)) 
     {
// Jc: parallel computation
//   for(int i = 0; i<numMols; i++)
//   {
       int i = molIndex;
       int i3 = 3 * molIndex;
       rij.x  = Dummy[i3];
       rij.y  = Dummy[i3 + 1];
       rij.z  = Dummy[i3 + 2];
       atomih1 = &atoms[i3];
       atomih2 = &atoms[i3 + 2];
       atomio  = &atoms[i3 + 1];
       atomid.position = rij; 
       rim     =  myEnsemble->molecules[molIndex].massCenter;  
     for(int j = molIndex+1; j<numMols; j++)
     {

       int j3 = 3 * j;
       rij.x  = Dummy[j3];
       rij.y  = Dummy[j3 + 1];
       rij.z  = Dummy[j3 + 2];
       atomjh1 = &atoms[j3];
       atomjh2 = &atoms[j3 + 2];
       atomjo  = &atoms[j3 + 1];
       atomjd.position = rij; 
       rijm     = rim - myEnsemble->molecules[j].massCenter;  
       myEnsemble->apply_pbc(rijm);

       PiTemp.x = Pi[i3];     
       PiTemp.y = Pi[i3+1];
       PiTemp.z = Pi[i3+2];
       PjTemp.x = Pi[j3];
       PjTemp.y = Pi[j3+1];
       PjTemp.z = Pi[j3+2];

       rij      = atomjo->position - atomio->position;
       myEnsemble->apply_pbc(rij);
       rij2     = rij.length()*rij.length();

// Jc: force resulting from the inducion dipoles, interactions between Pi-Charge, Pi-Pi 
// Jc: calculation from 20060126001
// Jc: the force between charge point - dipole was calcualted by Jianhui 
// Jc: details can be seen on draft calcualtion on the yellow notebook on 28th Feb 2006
/* Jc: ****************************************************************************************************
//     F and E of induced dipoles-charges calculated as Jianhui derivated in his Notebook on 28th Feb 2006 
//     but F and E of induced dipole- induced dipole are calculated from the equation (12) in 20060126001
//     ****************************************************************************************************
*/     
       if(rij2<= inCutoff2 ) 
       {

         // Jc: forces between jH1 - Pi
         rij      = atomid.position - atomjh1->position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length();
	 rijRij   = rij*rijm;
	 EijrR    = rijRij*rij/rij5 - rijm/(3.0*rij3);
         fij.x    = (PiTemp.x*(3*rij.x*rij.x-rij2) + PiTemp.y*(3*rij.x*rij.y) + PiTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PiTemp.x*(3*rij.x*rij.y) + PiTemp.y*(3*rij.y*rij.y-rij2) + PiTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PiTemp.x*(3*rij.x*rij.z) + PiTemp.y*(3*rij.z*rij.y) + PiTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
         fij      = -scaledQ*fij;

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
  
         atomio->force   += 0.5431676*fij;   //  add force on Dummy to O atom
         atomih1->force  += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomih2->force  += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomjh1->force -= fij;
         // Jc: polarization Energy Pi-Hj1
         EInduc  -= (PiTemp.x * KSwitch[i][j*9] + PiTemp.y * KSwitch[i][j*9+1] + PiTemp.z * KSwitch[i][j*9+2])/2.0;
	 dEinddV += scaledQ*(PiTemp*EijrR)/(voll);
	 //Einduc  +=  -scaledQ*(PiTemp*rij)/rij3*0.5;

         // Jc: forces between jH2 - Pi
         rij      = atomid.position - atomjh2->position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length(); 
	 rijRij   = rij*rijm;
	 EijrR    = rijRij*rij/rij5 - rijm/(3.0*rij3);
         fij.x    = (PiTemp.x*(3*rij.x*rij.x-rij2) + PiTemp.y*(3*rij.x*rij.y) + PiTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PiTemp.x*(3*rij.x*rij.y) + PiTemp.y*(3*rij.y*rij.y-rij2) + PiTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PiTemp.x*(3*rij.x*rij.z) + PiTemp.y*(3*rij.z*rij.y) + PiTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
         fij      = -scaledQ*fij;

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomio->force  += 0.5431676*fij;   // Jc: add force on Dummy to O atom
         atomih1->force += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomih2->force += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomjh2->force -= fij;
         // Jc: polarization Energy Pi-Hj2
         EInduc  -= (PiTemp.x * KSwitch[i][j*9+6] + PiTemp.y * KSwitch[i][j*9+7] + PiTemp.z * KSwitch[i][j*9+8])/2.0;
	 dEinddV += scaledQ*(PiTemp*EijrR)/(voll); 
	 //Einduc  +=  -scaledQ*(PiTemp*rij)/rij3*0.5;

         // Jc: forces between jO - Pi
         rij      = atomid.position - atomjd.position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length(); 
	 rijRij   = rij*rijm;
	 EijrR    = rijRij*rij/rij5 - rijm/(3.0*rij3);
         fij.x    = (PiTemp.x*(3*rij.x*rij.x-rij2) + PiTemp.y*(3*rij.x*rij.y) + PiTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PiTemp.x*(3*rij.x*rij.y) + PiTemp.y*(3*rij.y*rij.y-rij2) + PiTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PiTemp.x*(3*rij.x*rij.z) + PiTemp.y*(3*rij.z*rij.y) + PiTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
	 TRij.x   = (PiTemp.x*(5.0*rijRij*rij.x*rij.x/rij2 -rij.x*rijm.x -rijm.x*rij.x -rijRij) + PiTemp.y*(5.0*rijRij*rij.x*rij.y/rij2 -rij.x*rijm.y -rijm.x*rij.y) +\
		     PiTemp.z*(5.0*rijRij*rij.x*rij.z/rij2 -rij.x*rijm.z -rijm.x*rij.z) )/rij5; 
	 TRij.y   = (PiTemp.x*(5.0*rijRij*rij.y*rij.x/rij2 -rij.y*rijm.x -rijm.y*rij.x) + PiTemp.y*(5.0*rijRij*rij.y*rij.y/rij2 -rij.y*rijm.y -rijm.y*rij.y -rijRij) +\
		     PiTemp.z*(5.0*rijRij*rij.y*rij.z/rij2 -rij.y*rijm.z -rijm.y*rij.z) )/rij5; 
	 TRij.z   = (PiTemp.x*(5.0*rijRij*rij.z*rij.x/rij2 -rij.z*rijm.x -rijm.z*rij.x) + PiTemp.y*(5.0*rijRij*rij.z*rij.y/rij2 -rij.z*rijm.y -rijm.z*rij.y) +\
		     PiTemp.z*(5.0*rijRij*rij.z*rij.z/rij2 -rij.z*rijm.z -rijm.z*rij.z - rijRij) )/rij5; 
	 pTp      = TRij.x*PjTemp.x + TRij.y*PjTemp.y + TRij.z*PjTemp.z;   // notice that TRij is symmetric
	 //double pEp  = fij.x*PjTemp.x + fij.y*PjTemp.y + fij.z*PjTemp.z;
         fij      = (2)*scaledQ*fij;           // Jc: consider the negative charge rather than positive on site "O"

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomio->force  += 0.5431676*fij;   // Jc: add force on Dummy to O atom
         atomih1->force += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomih2->force += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomjo->force  -= 0.5431676*fij;
         atomjh1->force -= 0.5*0.4568324*fij;
         atomjh2->force -= 0.5*0.4568324*fij;
         // Jc: polarization Energy Pi-Oj and Pj-Oi
         EInduc  -= (PiTemp.x * KSwitch[i][j*9+3] + PiTemp.y * KSwitch[i][j*9+4] + PiTemp.z * KSwitch[i][j*9+5])/2.0;
         dEinddV += (-2.0)*scaledQ*(PiTemp*EijrR)/(voll) + pTp/voll;    // 1/2 in pTp not cosidered because the summation here is j>i
	 //Einduc  +=   2.0*scaledQ*PiTemp*rij/rij3 + 0.5*(-2.0)*scaledQ*PiTemp*rij/rij3;
         //EInduc  -= (PjTemp.x * KSwitch[j][i*9+3] + PjTemp.y * KSwitch[j][i*9+4] + PjTemp.z * KSwitch[j][i*9+5])/2.0;

         // Jc: forces between Pj - Pi     following 20060126001 EQ(12) p566
         rij      = atomjd.position - atomid.position;		// in Ahlstrom et al. the vector is in the opposite direction (in atom k distance is ri - rk)
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij5     = rij2 * rij2 * rij.length();
         fij      = (PiTemp.x * rij.x + PiTemp.y * rij.y + PiTemp.z * rij.z)*(PjTemp.x * rij.x + PjTemp.y * rij.y + PjTemp.z * rij.z)*rij*5.0/rij2;
         fij     += -(PiTemp.x * PjTemp.x + PiTemp.y * PjTemp.y + PiTemp.z * PjTemp.z)*rij;
         fij     += -(PiTemp.x * rij.x + PiTemp.y * rij.y + PiTemp.z * rij.z)*PjTemp -\
                  (PjTemp.x * rij.x + PjTemp.y * rij.y + PjTemp.z * rij.z)*PiTemp;
         fij      = fij * 3.0/rij5;

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomio->force  += 0.5431676*fij;    // Jc: add force on Dummy to O atom
         atomih1->force += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomih2->force += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomjo->force  -= 0.5431676*fij;    // Jc: add force on Dummy to O atom        
         atomjh1->force -= 0.5*0.4568324*fij;    //  add force on Dummy to H1 atom        
         atomjh2->force -= 0.5*0.4568324*fij;    //  add force on Dummy to H2 atom        

         // Jc: forces between iH1 - Pj
         rij      = atomjd.position - atomih1->position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length(); 
	 rijRij   = -rij*rijm;				// Now the Rij distance is (j - i)
	 EijrR    = rijRij*rij/rij5 + rijm/(3.0*rij3);  // -^--
         fij.x    = (PjTemp.x*(3*rij.x*rij.x-rij2) + PjTemp.y*(3*rij.x*rij.y) + PjTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PjTemp.x*(3*rij.x*rij.y) + PjTemp.y*(3*rij.y*rij.y-rij2) + PjTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PjTemp.x*(3*rij.x*rij.z) + PjTemp.y*(3*rij.z*rij.y) + PjTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
         fij      = -scaledQ*fij;

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomjo->force  += 0.5431676*fij;   // Jc: add force on Dummy to O atom
         atomjh1->force += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomjh2->force += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomih1->force -= fij;
         // Jc: polarization Energy Pj-Hi1
         EInduc  -= (PjTemp.x * KSwitch[j][i*9] + PjTemp.y * KSwitch[j][i*9+1] + PjTemp.z * KSwitch[j][i*9+2])/2.0;
         dEinddV += scaledQ*(PjTemp*EijrR)/(voll);
	 //Einduc  +=  -scaledQ*PjTemp*rij/rij3*0.5;

         // Jc: forces between iH2 - Pj
         rij      = atomjd.position - atomih2->position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length(); 
	 rijRij   = -rij*rijm;
	 EijrR    = rijRij*rij/rij5 + rijm/(3.0*rij3);
         fij.x    = (PjTemp.x*(3*rij.x*rij.x-rij2) + PjTemp.y*(3*rij.x*rij.y) + PjTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PjTemp.x*(3*rij.x*rij.y) + PjTemp.y*(3*rij.y*rij.y-rij2) + PjTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PjTemp.x*(3*rij.x*rij.z) + PjTemp.y*(3*rij.z*rij.y) + PjTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
         fij      = -scaledQ*fij;

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomjo->force  += 0.5431676*fij;   // Jc: add force on Dummy to O atom
         atomjh1->force += 0.5*0.4568324*fij;   //  add force on Dummy to H1 atom
         atomjh2->force += 0.5*0.4568324*fij;   //  add force on Dummy to H2 atom
         atomih2->force -= fij;
         // Jc: polarization Energy Pj-Hi2
         EInduc  -= (PjTemp.x * KSwitch[j][i*9+6] + PjTemp.y * KSwitch[j][i*9+7] + PjTemp.z * KSwitch[j][i*9+8])/2.0;
         dEinddV += scaledQ*(PjTemp*EijrR)/(voll);
	 //Einduc  +=  -scaledQ*PjTemp*rij/rij3*0.5;

         // Jc: forces between iO - Pj
         rij      = atomjd.position - atomid.position;
         myEnsemble->apply_pbc(rij);
         rij2     = rij.length()*rij.length();
         rij3     = rij.length()*rij2;
         rij5     = rij2*rij2*rij.length(); 
	 rijRij   = -rij*rijm;
	 EijrR    = rijRij*rij/rij5 + rijm/(3.0*rij3);
         fij.x    = (PjTemp.x*(3*rij.x*rij.x-rij2) + PjTemp.y*(3*rij.x*rij.y) + PjTemp.z*(3*rij.x*rij.z))/(rij5);               
         fij.y    = (PjTemp.x*(3*rij.x*rij.y) + PjTemp.y*(3*rij.y*rij.y-rij2) + PjTemp.z*(3*rij.y*rij.z))/(rij5);               
         fij.z    = (PjTemp.x*(3*rij.x*rij.z) + PjTemp.y*(3*rij.z*rij.y) + PjTemp.z*(3*rij.z*rij.z-rij2))/(rij5);               
         fij      = (2)*scaledQ*fij;   // Jc: consider the negative charge rather than positive on site "O"

         virial[XX] += fij.x * rij.x;
         virial[XY] += fij.y * rij.x;
         virial[XZ] += fij.z * rij.x;
         virial[YX] += fij.x * rij.y;
         virial[YY] += fij.y * rij.y;
         virial[YZ] += fij.z * rij.y;
         virial[ZX] += fij.x * rij.z;
         virial[ZY] += fij.y * rij.z;
         virial[ZZ] += fij.z * rij.z;
 
         atomjo->force  += 0.5431676*fij;         // Jc: add force on Dummy to O atom
         atomjh1->force += 0.5*0.4568324*fij;         //  add force on Dummy to H1 atom
         atomjh2->force += 0.5*0.4568324*fij;         //  add force on Dummy to H2 atom
         atomio->force  -= 0.5431676*fij;
         atomih1->force -= 0.5*0.4568324*fij;
         atomih2->force -= 0.5*0.4568324*fij;
         // Jc: polarization Energy Pj-Hi1
         EInduc  -= (PjTemp.x * KSwitch[j][i*9+3] + PjTemp.y * KSwitch[j][i*9+4] + PjTemp.z * KSwitch[j][i*9+5])/2.0;
         dEinddV += (-2.0)*scaledQ*(PjTemp*EijrR)/(voll);
	 //Einduc  +=  -(-2.0)*scaledQ*PjTemp*rij/rij3*0.5;
       }
     }
   } 
   }

/* Jc: test the real position from the continue simulation
   if((CNum == 0)&&(rank==(size-1)))
   {
      for(int i = 0; i<5; i++)
      {
        cout<<" realPosition "<<i<<"  "<<atoms[i].realPos.x<<"  "<<atoms[i].realPos.y<<"   "<<atoms[i].realPos.z<<endl;
        cout<<"     Position "<<i<<"  "<<atoms[i].position.x<<"  "<<atoms[i].position.y<<"   "<<atoms[i].position.z<<endl;
        cout<<"     Velocity "<<i<<"  "<<atoms[i].velocity.x<<"  "<<atoms[i].velocity.y<<"   "<<atoms[i].velocity.z<<endl;
      }
   }
// JC; end of test */

   }  // Jc: end of Induction
 
// Jc: calculate the induced dipole moments
// Jc: there are 2 ways to calculate the D, in this simulation, Method in 20060407001PE
// Jc: the total dipole moment M=Sum(Qi*Ri) + inducted dipole 

   scalarD =0.0;  // Jc: induced dipole moment

   if((CNum%100==0)&&(rank==(size-1))){

        double indDipole[numMols], averIndDipole = 0.0;//**
        FILE *fout;                                    //** 
        fout = fopen ("indivDipoles.out", "w");        //**

     for(int i = 0; i<numMols ;i++)
     {
       int i3 = i * 3;
       scalarD += sqrt(Pi[i3]*Pi[i3] + Pi[i3+1]*Pi[i3+1] + Pi[i3+2]*Pi[i3+2]);

       indDipole[i] = sqrt(Pi[i3]*Pi[i3] + Pi[i3+1]*Pi[i3+1] + Pi[i3+2]*Pi[i3+2]);                                                                                      //**
       averIndDipole = averIndDipole + indDipole[i]*(1.60217653/(0.0333564*11.78708976));                                                                               //**
       fprintf (fout, "%d    %f \n", i , indDipole[i]*(1.60217653/(0.0333564*11.78708976)) + 2*0.318227286*(atoms[0].scaledCharge/11.78708976)*(1.60217653/0.333564));  //**

       Dipole = atoms[i3].scaledCharge*atoms[i3].position;
       Dipole = Dipole + atoms[i3+2].scaledCharge*atoms[i3 + 2].position;
       Dipole.x = Dipole.x + atoms[i3+1].scaledCharge*Dummy[i3] + Pi[i3];
       Dipole.y = Dipole.y + atoms[i3+1].scaledCharge*Dummy[i3 + 1] + Pi[i3 + 1];
       Dipole.z = Dipole.z + atoms[i3+1].scaledCharge*Dummy[i3 + 2] + Pi[i3 + 2];
// Jc: commented out by Jianhui for MCYI calcualtion on 21/Nov-2007
//       cout<<i<<" molecular dipole is "<<sqrt(Dipole.x*Dipole.x + Dipole.y*Dipole.y + Dipole.z*Dipole.z )<<endl;
     }

       fprintf (fout, "\nAverage dipole = %f\n", averIndDipole/500 + 2*0.318227286*(atoms[0].scaledCharge/11.78708976)*(1.60217653/0.333564));   //**
       fclose (fout);                                                                                                                            //**

     scalarD = scalarD/(11.78708976*numMols);      // Jc: [Nm*e]
     scalarD = scalarD*1.60217653/0.0333564;       // Jc: [Debye] = C*m/3.33564e-30 = 1.0e-9*E_Charge/3.33564e-30
     scalarD = scalarD + 2*0.318227286*(atoms[0].scaledCharge/11.78708976)*(1.60217653/0.333564); // Jc: added permenent Dipole
     *ofEnergy<<setw(9)<<CNum<<setw(14)<<scalarD<<setw(14)<<Dipole.x<<setw(14)<<Dipole.y<<setw(14)<<Dipole.z<<endl; 
   }
  
// Jc: Parallel MCY 2-Body Calculation


// Jc: Axillrod-Teller 3-body interactions calculation on processors from 1 - (size-1)
// Jc: in the following calcualtion, one H2O molecule is treated as on unit interacting other units 

   start3 = clock();
   int numDecompose = (int) numAtoms/size;
   int counter =0;

   if ((numAtoms % size) == 0) numDecompose--;
   
   if(Alpha == -1.0) 
   {

     for(int index = 0; index <= numDecompose; index++) 
     {               

       int aIndex = index *size + rank;                                   // Jc: define the first atom: atomA

       if((aIndex) < (numAtoms - 6) )
       {
         atomA = &atoms[aIndex];                                   
         for(int bIndex = aIndex + 1; bIndex < numAtoms; bIndex++)        // Jc: define the second atom: atomB
         {   
           atomB = &atoms[bIndex];
           if((atomA->molID) != (atomB->molID))
           {
             rA = (atomA->position - atomB->position);
             myEnsemble->apply_pbc(rA);
             dA1  = rA.length();
             if(dA1 <= T_cutoff)
             {

               dA2 = dA1 * dA1; dA3 = dA2 * dA1; 
               dA4 = dA2 * dA2; dA5 = dA2 * dA3; 
               dA6 = dA3 * dA3;

               for(int cIndex = bIndex + 1; cIndex < numAtoms; cIndex++)   // Jc: define the third atom: atomC
               {  

                 atomC = &atoms[cIndex];
           
                 if((atomB->molID) != (atomC->molID))
                 { 
                   rB = (atomC->position - atomA->position);
                   myEnsemble->apply_pbc(rB);
                   dB1  = rB.length();

                   if(dB1 <= T_cutoff)
                   {

                     rC = (atomB->position - atomC->position);          
                     myEnsemble->apply_pbc(rC);
                     dC1  = rC.length();
 
                     if(dC1 <= T_cutoff)  
                     {
                       dB2 = dB1 * dB1; dB3 = dB2 * dB1;
                       dB4 = dB2 * dB2; dB5 = dB2 * dB3; dB6 = dB3 * dB3;
                       dC2 = dC1 * dC1; dC3 = dC2 * dC1;
                       dC4 = dC2 * dC2; dC5 = dC2 * dC3; dC6 = dC3 * dC3;

// Jc: end of 3-body calculation
                       counter++; 
// Jc: only consider the interactions between O, which is taken as the molar mass of water
                       if((atomA->atomType == 1)&&(atomB->atomType == 1)&&(atomC->atomType == 1))                    
// Jc: calculate 3-body force (cf. Luc PhD thesis, Chapter 6)
                       {
                       dVdRa =  (3.0*Vddd/(8.0*dA1))*(         \
                         - 8.0/(dA4*dB3*dC3) - 1.0/(dB5*dC5)     \
                         + 5.0*dB1/(dA6*dC5) + 5.0*dC1/(dA6*dB5) \
                         - 1.0/(dA2*dB3*dC5) - 1.0/(dA2*dB5*dC3) \
                         - 3.0/(dA4*dB1*dC5) - 3.0/(dA4*dB5*dC1) \
                         - 5.0/(dA6*dB1*dC3) - 5.0/(dA6*dB3*dC1) \
                         + 6.0/(dA4*dB3*dC3) );
            
            
                       dVdRb =  (3.0*Vddd/(8.0*dB1))*(         \
                         - 8.0/(dB4*dA3*dC3) - 1.0/(dA5*dC5)     \
                         + 5.0*dA1/(dB6*dC5) + 5.0*dC1/(dB6*dA5) \
                         - 1.0/(dB2*dA3*dC5) - 1.0/(dB2*dA5*dC3) \
                         - 3.0/(dB4*dA1*dC5) - 3.0/(dB4*dA5*dC1) \
                         - 5.0/(dB6*dA1*dC3) - 5.0/(dB6*dA3*dC1) \
                         + 6.0/(dB4*dA3*dC3) );
         
                       dVdRc =  (3.0*Vddd/(8.0*dC1))*(         \
                         - 8.0/(dC4*dB3*dA3) - 1.0/(dB5*dA5)     \
                         + 5.0*dB1/(dC6*dA5) + 5.0*dA1/(dC6*dB5) \
                         - 1.0/(dC2*dB3*dA5) - 1.0/(dC2*dB5*dA3) \
                         - 3.0/(dC4*dB1*dA5) - 3.0/(dC4*dB5*dA1) \
                         - 5.0/(dC6*dB1*dA3) - 5.0/(dC6*dB3*dA1) \
                         + 6.0/(dC4*dB3*dA3) );
         
// Jc:   This is the calculation of the forces:
// Jc:   fax is the force on the atom i in the X direction.
// Jc:   fbx is the force on the atom j in the X direction.
// Jc:   fcx is the force on the atom k in the X direction.

// Jc:   dXa is the relative coordinates of the 1st side in X direction...dYa,dZa
// Jc:   dXb is the relatice coordinates of the 2nd side in X direction...dYb,dZb.
// Jc:   dXc is the realtive coordinates of the 3rd side in X direction...dYc,dZc.

// Jc:   dXa = Ra.x; dYa = Ra.y; dZa = Ra.z;
// Jc:   dXa = Ra.x; dYa = Ra.y; dZa = Ra.z;
// Jc:   dXa = Ra.x; dYa = Ra.y; dZa = Ra.z;         
//cout << "vconst = " << Vddd << " cutoff = " << T_cutoff << " r-r-r = " << rA + rB + rC << endl;

                       fijA          = - rA*dVdRa - rB*dVdRb;
                       fijB          = - rA*(-dVdRa) - rC*dVdRc;
                       fijC          = - rB*(-dVdRb) - rC*(-dVdRc);

                       atomA->force += fijA;
                       atomB->force += fijB;
                       atomC->force += fijC;
         
// Jc:   Note, it is accumulating all the contributions of the same atom 
// Jc:   from all triangles where the atom is present
// Jc:   Calculation of the 3-body energy.
         
                       u3 +=  Vddd*(1.0/(dC3*dB3*dA3)              \
                         + (3.0*(dC2 + dB2 - dA2)*(dC2 - dB2 + dA2)  \
                         * (-dC2 + dB2 + dA2)/(8.*dC5*dB5*dA5)));

// Jc: how to calculate the 
                       virial[XX] += fijA.x * rA.x + fijB.x * rB.x + fijC.x * rC.x;
                       virial[XY] += fijA.y * rA.x + fijB.y * rB.x + fijC.y * rC.x;
                       virial[XZ] += fijA.z * rA.x + fijB.z * rB.x + fijC.z * rC.x;
                       virial[YX] += fijA.x * rA.y + fijB.x * rB.y + fijC.x * rC.y;
                       virial[YY] += fijA.y * rA.y + fijB.y * rB.y + fijC.y * rC.y;
                       virial[YZ] += fijA.z * rA.y + fijB.z * rB.y + fijC.z * rC.y;
                       virial[ZX] += fijA.x * rA.z + fijB.x * rB.z + fijC.x * rC.z;
                       virial[ZY] += fijA.y * rA.z + fijB.y * rB.z + fijC.y * rC.z;
                       virial[ZZ] += fijA.z * rA.z + fijB.z * rB.z + fijC.z * rC.z;
                       }    // Jc: identification of Oxygen atoms      
                     }      // Jc: end of rC cutoff condition
                   }        // Jc: end of rB cutoff condition
                 }          // Jc: atomC, B ID condition
               }            // Jc: K loop   
             }              // Jc: rA length condition 
           }                // Jc: AID = BID condition  
         }                  // Jc: J loop
       }                    // Jc: I loop
     }                      // Jc: decomposition loop 
   }                        // Jc: 3-Body Switch


//Jc: commented by for 2-body calculation on 28-08-2005
/*   
   end1 = clock();

   p_time = ((double)(end1-start3))/CLOCKS_PER_SEC;

   MPI::COMM_WORLD.Gather(&p_time,1,MPI::DOUBLE,&pp_time,1,MPI::DOUBLE,0); 
   MPI::COMM_WORLD.Gather(&counter,1,MPI::INT,&counterc,1,MPI::INT,0); 
 
   if(rank == 0)
   { 
   for(int numProcs = 0; numProcs<size;numProcs++)
    {     
      *outTimeFile<<"  "<<numProcs<<"  "<<pp_time[numProcs]<<"  "<<counterc[numProcs]<<endl;
    }
   }
*/
   double temp = 0.0;

//   MPI::COMM_WORLD.Allreduce(&u3,&temp,1,MPI::DOUBLE,MPI::SUM);
   MPI_Allreduce(&u3,&temp,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
   u3 = temp; 

//   MPI::COMM_WORLD.Allreduce(&EInduc,&temp,1,MPI::DOUBLE,MPI::SUM);
   MPI_Allreduce(&EInduc,&temp,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
   EInduc = temp;

   temp = 0.0;
   MPI_Allreduce(&dEinddV,&temp,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
   dEinddV = temp;
 //  temp = 0.0;
 //  MPI_Allreduce(&Einduc,&temp,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
 //  Einduc = temp;

   myEnsemble->myEnergy.inducEnergy = EInduc;
   myEnsemble->myEnergy.TBEnergy    = u3; 
   myEnsemble->myLustig.inducEn     = Einduc;
   myEnsemble->myLustig.inducDeriv  = dEinddV;
/*   if((rank ==0)&&(CNum>1)) 
   {
     if(rank==0)
     {
       char fileNum[] = "0123456789";
       char fileName[] = "Posi0000.dat";
       int firstDigit  = int(CNum / 1000);
       int secondDigit = int((CNum%1000)/100);
       int thirdDigit  = int((CNum%100)/10);
       int fourthDigit = int(CNum%10);
       fileName[4] = fileNum[firstDigit];
       fileName[5] = fileNum[secondDigit];
       fileName[6] = fileNum[thirdDigit];
       fileName[7] = fileNum[fourthDigit];

       ofCoordinate = new ofstream(fileName,ios::out);
       for(int numIndex = 0; numIndex< 1500;numIndex++)
         *ofCoordinate<<setw(6)<<atoms[numIndex].atomType<<scientific<<setw(14)<<10*(atoms[numIndex].position);
       ofCoordinate->close();
     }     
   }
*/                                      
/*   if((CNum >= 60)&&(CNum <= 70))
   {   
     double forceArray[1500][3],tempForceArray[1500][3];

     for (int numIndex = 0;numIndex < numAtoms; numIndex++)
     {
       forceArray[numIndex][0]     = atoms[numIndex].force.x;
       forceArray[numIndex][1]     = atoms[numIndex].force.y;
       forceArray[numIndex][2]     = atoms[numIndex].force.z;
     }
  
     MPI::COMM_WORLD.Allreduce(forceArray,tempForceArray,4500,MPI::DOUBLE,MPI::SUM);
     MPI::COMM_WORLD.Barrier();
     if(CNum==70) cout<<" after reduction force "<<tStep<<" at CPU "<<rank<<": "<<tempForceArray[224][0]\
       <<" "<<tempForceArray[224][1]<<" "<<tempForceArray[224][2]<<endl;

     if(rank==0)
     {
       char fileNum[] = "0123456789";
       char fileName[] = "Fore0000.dat";
       int firstDigit  = int(CNum / 1000);
       int secondDigit = int((CNum%1000)/100);
       int thirdDigit  = int((CNum%100)/10);
       int fourthDigit = int(CNum%10);
       fileName[4] = fileNum[firstDigit];
       fileName[5] = fileNum[secondDigit];
       fileName[6] = fileNum[thirdDigit];
       fileName[7] = fileNum[fourthDigit];

       ofCoordinate = new ofstream(fileName,ios::out);
       for(int numIndex = 0; numIndex< 1500;numIndex++)
         *ofCoordinate<<setw(6)<<numIndex<<scientific<<setw(14)<<tempForceArray[numIndex][0]\
           <<setw(14)<<tempForceArray[numIndex][1]<<setw(14)<<tempForceArray[numIndex][2]<<endl;
       ofCoordinate->close();
     }
   } 
*/

   CNum++;

   for (Int k = XX; k <= ZZ; k++)
   {
      myEnsemble->virial[k] -= virial[k];
        // myEnsemble->molVirial[k] -= molVirial[k];
   }
}

// Energy is calculated by Jianhui Li on September 2004, based on the NCC ab Initio Potential
// Molecular Dynamics Simulation of Liquid Water Usiing the NCC ab Initio Potential, U.Niesar,G.Corongiu,
// E.Clementi,G.R.Kneller, and D.K.Bhattacharya, Journal of Physics Chemistry, 1990,94,7949-7956
// Li's literature code: 20040810001
// JC all the terms in the NCC potential are carries out in the above caluclation
// JC however the Newtonian forces acting on the dummy charges are actually added 
// JC on the Oxygen nuclei in the attentive steps, other techniques might applied 
// JC in previous research, but so far we haven't found any report on the detailed 
// JC techniques.And there is no 
// Beyond the cutoff, usually the repulsive term can be neglected.
// long_range_correct() will make correction to dispersion term 
// algorithm refering to GROMACS Appendix C

void NccForce::long_range_correct()
{
    Int numTypes = myEnsemble->nAtomTypes;
    Int *atomNum = new Int[numTypes];
    Double val = 0.0;

    for (Int i = 0; i < numTypes; i++)
        atomNum[i] = 0;

    // count atom number for each type
    for (Int i = 0; i < numAtoms; i++)
    {   
        int type = atoms[i].atomType;
        atomNum[type] += 1;
    }

    for (Int i = 0; i < numTypes; i++)
    {
        for (Int j = 0; j < numTypes; j++)
        {
            LJPairParam ljParam = params->get_lj_parameter(i, j);
            Double sigma2 = ljParam.sigma;
            Double eps4 = ljParam.eps;

            val += atomNum[i]*atomNum[j]*eps4*sigma2*sigma2*sigma2;
        }
    }

    eLrc = -2*PI*val/(3*myEnsemble->boxLx*myEnsemble->boxLy*myEnsemble->boxLz*cutOff*cutOff*cutOff);
    vLrc = -eLrc;          
}

void NccForce::write_force_info(ofstream& of)
{
    of << "Ncc Force" << endl;
    of << "cutoff2: " << cutOff2 << endl;
    if (switchOn)
        of << "compute LJ force with switch function" << endl;
    if (computeCoulomb)
        of << "Non-bonded force include coulomb" << endl;
    of << "Nc parameters:" << endl;
    of << "type1" << '\t' << "type2" << '\t' << "eps4" << '\t' << "sigma2" << endl;
    for (Int i = 0; i <myEnsemble->nAtomTypes; i++)
    {
        for (Int j = 0; j < myEnsemble->nAtomTypes; j++)
        {
            LJPairParam ljParam = params->get_lj_parameter(i, j);
            of << i << '\t' << j << '\t' << ljParam.eps << '\t' << ljParam.sigma << endl;
        }
    }
    of << "Long range correct energy: " << eLrc << endl;        
    of << endl;
}

void NccForce::write_energy(ofstream& of) // JC designed by Jianhui Li to store the 
{
      of << WPotential <<'\t' << CPotential <<endl; 
      WPotential = 0.0;
      CPotential = 0.0;
}

void NccForce::GaussElimination()
{
  int k;
  int N = numMols*3;

  for(k=0; k < N-1; k++)
  {
    for(int i=k+1;i<N;i++)
    {
      double l_ik = A[i][k]/A[k][k];
      for(int j=k;j<N;j++)
        A[i][j] = A[i][j] - l_ik*A[k][j];
      Pi[i] = Pi[i] - l_ik*Pi[k]; 
    }
  }

  // (backsolveing to solve Ux=y)  
  Pi[N-1] = Pi[N-1]/A[N-1][N-1];
  for(k=N-2;k>=0;k--)
  {
    for(int j=k+1;j<N;j++)
      Pi[k] -= A[k][j]*Pi[j];
    Pi[k] = Pi[k]/A[k][k];
  }
//  cout<<"solving induction energy by GaussElimination......"<<endl;
}

void NccForce:: ConjugateGradient(){

  int dim = numMols*3;
  const double tolerance = 1.0e-14;
  double c,t,d,dotV;
  double r[1500], v[1500], z[1500];

  c = 0.0; d = 0.0;t = 0.0,dotV=0.0;

  for(int i =0;i<dim;i++)
  {
     Pi[i]  = 1.0;
  } 
     
  for(int i=0;i<dim;i++)
  { 
    r[i] =  Ei0[i]; 
    for(int j = 0;j<dim;j++)
    {
      r[i] -= A[i][j] * Pi[j]; 
    } 
    v[i] = r[i];
    c    += r[i]*r[i];
    dotV += v[i]*v[i]; 
  }

// Jc: interation begins
  for(int i=0;i<dim;i++){
    if(sqrt(dotV)<tolerance){
      cerr << "An error has occurred in ConjugateGradient: execution of function terminated" << endl;
      break;
    }
    double dotVZ = 0.0;
    for(int j =0;j<dim;j++)
    {  
       z[j] = 0.0;
       for(int k = 0; k<dim;k++)
       {
         z[j] += A[j][k]*v[k];
       }
       dotVZ += v[j]*z[j];
    }
    t = c/dotVZ;

    d = 0.0;
    for(int j =0;j<dim;j++)
    {
      Pi[j] += t*v[j];
      r[j]  -= t*z[j];
      d     += r[j]*r[j];
    }

    if(sqrt(d) < tolerance)
      break;

    dotV = 0.0;
    for(int j =0; j<dim;j++)
    {
      v[j] = r[j] + (d/c)*v[j];
      dotV += v[j]*v[j];
    }
    c = d;
  }
//   cout<<"solving induction energy by conjugate gradient ......"<<endl;

} 

